package kplanning.generator;

import org.jetbrains.annotations.Nullable;
import org.jgrapht.DirectedGraph;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;

import java.io.FileNotFoundException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.*;

public class GenerateProblems {
	private static final String LS = System.lineSeparator();

//	public static void main(String[] args) {
//		List<PredicateExclusive> predicateExclusives = new ArrayList<>();
//		PredicateExclusive predicateExclusive = new PredicateExclusive(true);
//		predicateExclusive.addPredicateProbability(new PredicateProbability("haveTrap", 0.45));
//		predicateExclusive.addPredicateProbability(new PredicateProbability("haveMonster", 0.45));
//		predicateExclusive.addPredicateProbability(new PredicateProbability("haveSword", 0.05));
//		predicateExclusives.add(predicateExclusive);
//		generateAndWriteToFile("rpg", 6, 11*11, predicateExclusives, true, new Grid(11, 11));
//	}

	public static void main(String[] args) {
		List<PredicateExclusive> predicateExclusives = new ArrayList<>();
		PredicateExclusive predicateExclusive = new PredicateExclusive(false);
		predicateExclusive.addPredicateProbability(new PredicateProbability("in", 0.5, "bar"));
		predicateExclusives.add(predicateExclusive);
		generateAndWriteToFile("planning-examples/drinkanddrive-generated/", 5, 20, predicateExclusives, false, null);
	}

	public static void generateAndWriteToFile(String domainDir, int problemNumber, int numCities, List<PredicateExclusive> predicateExclusives, boolean skipFirstLast, Grid grid) {
		String[] split = domainDir.split("/");
		String domainName = split[split.length-1];
		String s = generateDrinkAndDriveProblem(domainName, problemNumber, numCities, predicateExclusives, skipFirstLast, grid);
		try {
			PrintWriter writer = new PrintWriter(domainDir + "pb" + problemNumber + ".pddl", "UTF-8");
			writer.print(s);
			writer.close();
		} catch (FileNotFoundException | UnsupportedEncodingException e) {
			e.printStackTrace();
		}
	}

	private static String generateDrinkAndDriveProblem(String domainName, int problemNumber, int numCities, List<PredicateExclusive> predicateExclusives, boolean skipFirstLast, Grid grid) {
		DirectedGraph<String, DefaultEdge> g = getRandomConnectedGraph(numCities, grid);

		String tabs = "";
		String s = "; Generated by ProblemGenerator - Problem " + problemNumber + " at " + new Date() + LS;
		s += tabs + "(";
		s += "define (problem pb" + problemNumber + ")" + LS;
		tabs += "\t";
		s += tabs + "(:domain " + domainName + ")" + LS;
		s += tabs + "(:requirements :strips :typing :negative-preconditions)" + LS;

		// Objects
		s += tabs + "(:objects"  + LS;
		tabs += "\t";
		s += tabs;
		Map<PredicateProbability, String> objects = new HashMap<>();
		Map<PredicateProbability, String> objectsPredicates = new HashMap<>();
		for(PredicateExclusive predicateExclusive : predicateExclusives) {
			if(!predicateExclusive.treatAsRandom) {
				for (PredicateProbability predicateProbability : predicateExclusive.getPredicateProbabilitySet()) {
					objects.put(predicateProbability, tabs);
					objectsPredicates.put(predicateProbability, "");
				}
			}
		}

		Random r = new Random();
		for(int i=1;i<=numCities;i++) {
			s += "loc" + i + " ";
			for (PredicateExclusive predicateExclusive : predicateExclusives) {
				if(!predicateExclusive.treatAsRandom) {
					for (PredicateProbability predicateProbability : predicateExclusive.getPredicateProbabilitySet()) {
						if (r.nextDouble() <= predicateProbability.probability) {
							objects.put(predicateProbability, objects.get(predicateProbability) + (predicateProbability.object + i) + " ");
							objectsPredicates.put(predicateProbability, objectsPredicates.get(predicateProbability) + tabs + "(" + predicateProbability.predicate + " " + (predicateProbability.object + i) + " loc" + i + ")" + LS);
						}
					}
				}
			}
		}
		s += "- location" + LS;

		for (PredicateExclusive predicateExclusive : predicateExclusives) {
			if(!predicateExclusive.treatAsRandom) {
				for (PredicateProbability predicateProbability : predicateExclusive.getPredicateProbabilitySet()) {
					s += objects.get(predicateProbability) + "- " + predicateProbability.object + LS;
				}
			}
		}
		tabs = "\t";
		s += tabs + ")" + LS;

		// Init
		s += tabs + "(:init" + LS;
		tabs += "\t";

		// At
		s += tabs + "(at loc1)" + LS;
		s += LS;

		// Connected
		for(DefaultEdge edge : g.edgeSet()) {
			s += tabs + "(connected " + g.getEdgeSource(edge) + " " + g.getEdgeTarget(edge) + ")" + LS;
			s += tabs + "(connected " + g.getEdgeTarget(edge) + " " + g.getEdgeSource(edge) + ")" + LS;
		}
		s += LS;

		// Predicates
		for(PredicateExclusive predicateExclusive : predicateExclusives) {
			if(predicateExclusive.treatAsRandom) {
				for (String vertex : g.vertexSet()) {
					if ((!skipFirstLast || !vertex.equals("loc" + numCities)) && (!skipFirstLast || !vertex.equals("loc1"))) {
						PredicateProbability randomPredicate = predicateExclusive.getRandomPredicate(r.nextDouble());
						if (randomPredicate != null) {
							s += tabs + "(" + randomPredicate.predicate + " " + vertex + ")" + LS;
						}
					}
				}
			} else {
				for (PredicateProbability predicateProbability : predicateExclusive.getPredicateProbabilitySet()) {
					s += objectsPredicates.get(predicateProbability) + LS;
				}
			}
		}

		tabs = "\t";
		s += tabs + ")" + LS;
		s += LS;

		// Goal
		s += tabs + "(:goal" + LS;
		s += "\t\t(and\n" +
				// TODO: add this as a goal!
//				"\t\t\t(drunk)\n" +
				"\t\t\t(at loc" + numCities + ")\n" +
				"\t\t)\n" +
				"\t)\n";

		s += ")";
		return s;
	}

	private static DirectedGraph<String, DefaultEdge> getRandomConnectedGraph(int numNodes, Grid grid) {
		DirectedGraph<String, DefaultEdge> g = new DefaultDirectedGraph<>(DefaultEdge.class);
		for(int i=1;i<=numNodes;i++) {
			g.addVertex("loc" + i);
		}
		if(grid != null) {
			for(int i=1;i<=grid.height;i++) { //4
				for(int j=1;j<=grid.width;j++){ //5
					int num = grid.width * (i-1) + j;
					if(num % grid.width != 0 && num + 1 <= numNodes) {
						g.addEdge("loc" + num, "loc" + (num + 1));
					}
					if(num + grid.width <= numNodes) {
						g.addEdge("loc" + num, "loc" + (num + grid.width));
					}
				}
			}
		} else {
			RandomSet<String> nodes = new RandomSet<>(g.vertexSet());
			RandomSet<String> s = new RandomSet<>(g.vertexSet());
			RandomSet<String> t = new RandomSet<>();
			Random random = new Random();
			String currentNode = s.removeAt(random.nextInt(s.size()));
			t.add(currentNode);

			// Connected
			while (!s.isEmpty()) {
				String neighborNode = nodes.get(random.nextInt(nodes.size()));
				if (!t.contains(neighborNode)) {
					g.addEdge(currentNode, neighborNode);
					s.remove(neighborNode);
					t.add(neighborNode);
				}
				currentNode = neighborNode;
			}

			// Random edges
			for (int i = 0; i < numNodes; i++) {
				for (int j = 0; j < numNodes; j++) {
					if (i != j) {
						if (random.nextDouble() > (((double) Math.abs(i - j)) / numNodes)) {
							if (random.nextDouble() < 0.2) {
								g.addEdge("loc" + (i + 1), "loc" + (j + 1));
							}
						}
					}
				}
			}
		}
		return g;
	}

	public static class PredicateExclusive {
		private Set<PredicateProbability> predicateProbabilitySet;
		private double sum;
		private boolean treatAsRandom;

		PredicateExclusive(boolean treatAsRandom) {
			predicateProbabilitySet = new HashSet<>();
			sum = 0;
			this.treatAsRandom = treatAsRandom;
		}

		Set<PredicateProbability> getPredicateProbabilitySet() {
			return predicateProbabilitySet;
		}

		void addPredicateProbability(PredicateProbability predicateProbability) {
			this.predicateProbabilitySet.add(predicateProbability);
			this.sum += predicateProbability.probability;
			if(this.sum > 1) {
				throw new IllegalStateException("PredicateExclusive could not be greater than [1]");
			}
		}

		@Nullable
		PredicateProbability getRandomPredicate(double p) {
			double internalSum = 1;
			for(PredicateProbability predicateProbability : predicateProbabilitySet) {
				internalSum -= predicateProbability.probability;
				if(p >= internalSum) {
					return predicateProbability;
				}
			}
			return null;
		}
	}

	public static class PredicateProbability {
		String predicate;
		double probability; //[0;1]
		String object;

		PredicateProbability(String predicate, double probability) {
			this(predicate, probability, null);
		}

		PredicateProbability(String predicate, double probability, String object) {
			this.predicate = predicate;
			this.probability = probability;
			if(probability < 0 || probability > 1) {
				throw new IllegalStateException("probability must be in [0;1] range");
			}
			this.object = object;
		}
	}

	public static class Grid {
		int height;
		int width;

		public Grid(int height, int width) {
			this.height = height;
			this.width = width;
		}
	}
}
